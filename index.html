<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="OARS Exam Scheduler ‚Äî HPU Testing Center exam scheduling tool">
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üìã</text></svg>">
<title>OARS Exam Scheduler ‚Äî HPU Testing Center</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
<style>
@import url('https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@300;400;500;600&family=IBM+Plex+Sans:wght@300;400;500;600;700&display=swap');

:root {
  --bg: #f0f2f5;
  --surface: #ffffff;
  --border: #d8dce6;
  --border2: #eaedf3;
  --text: #1a1f2e;
  --muted: #6b7494;
  --accent: #2655d4;
  --accent-light: #e8eeff;
  --green: #1a7a4a;   --green-bg: #e6f5ed;
  --yellow: #8a6500;  --yellow-bg: #fef9e6;
  --red: #c0281a;     --red-bg: #fdecea;
  --orange: #b85c00;  --orange-bg: #fff1e0;
  --mono: 'IBM Plex Mono', monospace;
  --sans: 'IBM Plex Sans', sans-serif;
}

* { box-sizing: border-box; margin: 0; padding: 0; }
html, body { height: 100%; }
body { background: var(--bg); color: var(--text); font-family: var(--sans); font-size: 13px; min-height: 100vh; }

/* HEADER */
header {
  background: var(--text); color: #fff; padding: 0 28px; height: 52px;
  display: flex; align-items: center; gap: 12px;
  position: sticky; top: 0; z-index: 100;
}
.logo { font-family: var(--mono); font-weight: 600; font-size: 14px; color: #fff; }
.logo span { color: #7ea5ff; }
.hdr-div { width: 1px; height: 20px; background: rgba(255,255,255,0.15); }
.hdr-sub { font-family: var(--mono); font-size: 10px; color: rgba(255,255,255,0.4); letter-spacing: 1px; text-transform: uppercase; }
.hdr-right { margin-left: auto; display: flex; gap: 8px; align-items: center; }

/* LAYOUT */
.layout { display: flex; height: calc(100vh - 52px); }
.sidebar { width: 272px; min-width: 272px; background: var(--surface); border-right: 1px solid var(--border); overflow-y: auto; display: flex; flex-direction: column; }
.main { flex: 1; overflow: hidden; display: flex; flex-direction: column; }

/* SIDEBAR */
.sb-sec { padding: 16px 18px; border-bottom: 1px solid var(--border2); }
.sb-title { font-family: var(--mono); font-size: 9px; font-weight: 600; letter-spacing: 1.5px; text-transform: uppercase; color: var(--muted); margin-bottom: 10px; }

/* UPLOAD */
.upload-card {
  border: 1.5px dashed var(--border); border-radius: 9px; padding: 12px;
  text-align: center; cursor: pointer; transition: all 0.15s;
  position: relative; margin-bottom: 8px; background: var(--bg);
}
.upload-card:last-child { margin-bottom: 0; }
.upload-card:hover { border-color: var(--accent); background: var(--accent-light); }
.upload-card.loaded { border-style: solid; background: var(--surface); }
.upload-card.approved.loaded { border-color: var(--green); }
.upload-card.pending.loaded  { border-color: var(--yellow); }
.upload-card input[type=file] { position: absolute; inset: 0; opacity: 0; cursor: pointer; width: 100%; height: 100%; }
.uc-icon { font-size: 18px; margin-bottom: 4px; }
.uc-type { font-family: var(--mono); font-size: 9px; font-weight: 600; letter-spacing: 1.2px; text-transform: uppercase; margin-bottom: 2px; }
.uc-type.approved { color: var(--green); } .uc-type.pending { color: var(--yellow); }
.uc-hint { font-size: 11px; color: var(--muted); }
.uc-fname { font-size: 10px; color: var(--muted); margin-top: 3px; font-family: var(--mono); word-break: break-all; }

/* STATS */
.stats-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 7px; }
.stat-box { background: var(--bg); border-radius: 7px; padding: 9px 11px; border: 1px solid var(--border2); }
.stat-num { font-family: var(--mono); font-size: 20px; font-weight: 600; line-height: 1; margin-bottom: 2px; }
.stat-num.a { color: var(--green); } .stat-num.p { color: var(--yellow); }
.stat-num.c { color: var(--red); }   .stat-num.t { color: var(--accent); }
.stat-num.r { color: var(--orange); }
.stat-lbl { font-size: 9px; color: var(--muted); font-family: var(--mono); text-transform: uppercase; letter-spacing: 0.8px; }

/* FILTERS */
.filter-group { display: flex; flex-direction: column; gap: 5px; }
.filter-btn {
  font-family: var(--mono); font-size: 11px; font-weight: 500;
  padding: 7px 10px; border-radius: 7px; border: 1.5px solid var(--border);
  background: transparent; color: var(--muted); cursor: pointer;
  transition: all 0.12s; text-align: left;
  display: flex; align-items: center; gap: 7px;
}
.filter-btn .fb-dot { width: 7px; height: 7px; border-radius: 50%; flex-shrink: 0; }
.filter-btn.fall  .fb-dot { background: var(--accent); }
.filter-btn.fappr .fb-dot { background: var(--green); }
.filter-btn.fpend .fb-dot { background: var(--yellow); }
.filter-btn.fconf .fb-dot { background: var(--red); }
.filter-btn.fremv .fb-dot { background: var(--orange); }
.filter-btn .fb-count { margin-left: auto; font-size: 10px; background: var(--bg); border-radius: 9px; padding: 1px 6px; color: var(--muted); }
.filter-btn:hover  { color: var(--text); border-color: var(--text); }
.filter-btn.active { color: var(--text); border-color: var(--accent); background: var(--accent-light); }
.filter-btn.active .fb-count { background: var(--accent); color: #fff; }

/* OFFICE ROOMS */
.office-list { display: flex; flex-direction: column; gap: 4px; max-height: 180px; overflow-y: auto; }
.office-item {
  display: flex; align-items: center; gap: 8px;
  padding: 5px 8px; background: var(--bg); border-radius: 6px;
  border: 1px solid var(--border2); font-size: 11px;
}
.office-item .oi-room { font-family: var(--mono); font-weight: 600; color: var(--accent); min-width: 36px; }
.office-item .oi-name { color: var(--muted); flex: 1; }
.office-item .oi-floor { font-family: var(--mono); font-size: 9px; color: var(--muted); }
.office-rm-del { margin-left: auto; background: none; border: none; color: var(--muted); cursor: pointer; font-size: 13px; padding: 0 2px; line-height: 1; }
.office-rm-del:hover { color: var(--red); }
.add-office-row { display: flex; gap: 5px; margin-top: 8px; }
.add-office-row input {
  flex: 1; font-family: var(--mono); font-size: 11px;
  padding: 5px 8px; border-radius: 6px; border: 1px solid var(--border);
  background: var(--bg); color: var(--text); outline: none;
}
.add-office-row input:focus { border-color: var(--accent); }
.add-office-row button {
  font-family: var(--mono); font-size: 11px; padding: 5px 10px;
  border-radius: 6px; border: none; background: var(--accent); color: #fff; cursor: pointer;
}

/* EXPORT */
.export-btn {
  width: 100%; font-family: var(--mono); font-size: 11px; font-weight: 600;
  letter-spacing: 0.5px; padding: 9px 14px; border-radius: 7px; border: none;
  background: var(--accent); color: #fff; cursor: pointer; transition: all 0.12s; text-transform: uppercase;
}
.export-btn:hover:not(:disabled) { background: #1a42b0; }
.export-btn:disabled { opacity: 0.35; cursor: not-allowed; }

/* LEGEND */
.legend-row { display: flex; align-items: center; gap: 7px; margin-bottom: 5px; font-size: 11px; color: var(--muted); }
.legend-row:last-child { margin-bottom: 0; }
.legend-sw { width: 26px; height: 13px; border-radius: 3px; flex-shrink: 0; border: 1px solid rgba(0,0,0,0.08); }

/* TOP BAR */
.topbar {
  background: var(--surface); border-bottom: 1px solid var(--border);
  padding: 9px 20px; display: flex; align-items: center; gap: 10px; flex-shrink: 0; flex-wrap: wrap;
}
.topbar-label { font-family: var(--mono); font-size: 10px; font-weight: 600; color: var(--muted); text-transform: uppercase; letter-spacing: 1px; }
.date-tab {
  font-family: var(--mono); font-size: 11px; padding: 5px 11px; border-radius: 6px;
  border: 1.5px solid var(--border); background: transparent; color: var(--muted); cursor: pointer; transition: all 0.12s;
}
.date-tab:hover { border-color: var(--accent); color: var(--accent); }
.date-tab.active { background: var(--accent); border-color: var(--accent); color: #fff; }

/* GRID */
.table-area { flex: 1; overflow: auto; }
.grid-wrap { overflow: auto; height: 100%; }

table.sched { border-collapse: collapse; font-size: 12px; table-layout: fixed; min-width: 100%; }

table.sched th {
  background: var(--text); color: rgba(255,255,255,0.85);
  padding: 8px 8px; font-family: var(--mono); font-size: 10px; font-weight: 500;
  letter-spacing: 0.7px; text-transform: uppercase; white-space: nowrap;
  border-right: 1px solid rgba(255,255,255,0.07);
  position: sticky; top: 0; z-index: 10; min-width: 150px;
}
table.sched th.time-th { min-width: 82px; width: 82px; background: #10141e; z-index: 20; left: 0; }
table.sched th.floor-th { background: #1f2640; color: #7ea5ff; font-size: 12px; letter-spacing: 1.5px; text-align: center; padding: 7px 8px; border-bottom: 2px solid #2655d4; }
table.sched .fhr th { position: sticky; top: 0; z-index: 11; }
table.sched .shr th { position: sticky; top: 27px; z-index: 10; }

table.sched td {
  border-right: 1px solid var(--border2); border-bottom: 1px solid var(--border2);
  vertical-align: top; padding: 0; min-width: 150px; width: 150px; height: 30px; position: relative;
  overflow: visible;
}
table.sched td.time-cell {
  background: #f8f9fc; padding: 5px 8px; font-family: var(--mono); font-size: 10px;
  color: var(--muted); font-weight: 500; border-right: 2px solid var(--border);
  white-space: nowrap; position: sticky; left: 0; z-index: 5; min-width: 82px; width: 82px;
}
table.sched td.time-cell.hour { color: var(--text); font-weight: 600; background: #edf0f7; border-top: 1px solid var(--border); }
/* office empty cells ‚Äî slightly tinted so staff can see them */
table.sched td.office-cell { background: #fafbff; }

/* STUDENT BLOCK */
.sb {
  border-radius: 5px; padding: 5px 6px; overflow: hidden;
  cursor: default; border-left: 3px solid transparent;
  box-shadow: 0 1px 3px rgba(0,0,0,0.1); transition: box-shadow 0.15s;
}
.sb:hover { box-shadow: 0 3px 10px rgba(0,0,0,0.22); z-index: 10 !important; }
.sb.approved { background: var(--green-bg); border-left-color: var(--green); }
.sb.pending  { background: var(--yellow-bg); border-left-color: var(--yellow); }
.sb.conflict { background: var(--red-bg); border-left-color: var(--red); }
.sb.removed  { background: var(--orange-bg); border-left-color: var(--orange); opacity: 0.85; }
.sb.manual   { background: #f0f4ff; border-left-color: var(--accent); border: 1px dashed var(--accent); }

.sb-name  { font-family: var(--sans); font-weight: 600; font-size: 11px; color: var(--text); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; line-height: 1.3; }
.sb-course{ font-size: 10px; color: var(--muted); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; line-height: 1.3; margin-top: 1px; }
.sb-accom { font-size: 9px; color: var(--muted); font-style: italic; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; line-height: 1.3; margin-top: 2px; opacity: 0.85; }
.sb-badge {
  display: inline-block; font-size: 8px; font-family: var(--mono); font-weight: 600;
  padding: 1px 5px; border-radius: 3px; margin-top: 2px; letter-spacing: 0.4px;
}
.sb-badge.conflict { background: var(--red); color: #fff; }
.sb-badge.removed  { background: var(--orange); color: #fff; }
.sb-badge.online   { background: #1a5fa0; color: #fff; }
.sb-badge.paper    { background: #555; color: #fff; }


/* EMPTY */
.empty-state { display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; color: var(--muted); gap: 10px; padding: 40px; }
.empty-icon { font-size: 44px; opacity: 0.35; }
.empty-title { font-family: var(--sans); font-size: 17px; font-weight: 600; color: var(--text); opacity: 0.45; }
.empty-sub { font-size: 12px; text-align: center; max-width: 300px; line-height: 1.6; }

/* TOOLTIP */
.tooltip {
  position: fixed; background: #1a1f2e; color: #fff; border-radius: 8px;
  padding: 10px 13px; font-size: 12px; pointer-events: none; z-index: 999;
  max-width: 280px; box-shadow: 0 8px 24px rgba(0,0,0,0.3); display: none; line-height: 1.6;
}

/* NOTIF */
.notif {
  position: fixed; bottom: 22px; right: 22px; background: var(--text); color: #fff;
  border-radius: 9px; padding: 11px 18px; font-size: 12px; font-family: var(--mono);
  box-shadow: 0 8px 28px rgba(0,0,0,0.2); animation: sup 0.25s ease; z-index: 9999;
}
@keyframes sup { from { transform: translateY(14px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }

::-webkit-scrollbar { width: 10px; height: 10px; }
::-webkit-scrollbar-track { background: #e4e8f0; border-radius: 4px; }
::-webkit-scrollbar-thumb { background: #9aa5c4; border-radius: 4px; border: 2px solid #e4e8f0; }
::-webkit-scrollbar-thumb:hover { background: #6b7494; }
::-webkit-scrollbar-corner { background: #e4e8f0; }
</style>
</head>
<body>

<header>
  <div class="logo">OARS <span>Exam Scheduler</span></div>
  <div class="hdr-div"></div>
  <div class="hdr-sub">Testing Center ¬∑ High Point University</div>
  <div class="hdr-right">
    <span id="lastUpload" style="font-family:var(--mono);font-size:10px;color:rgba(255,255,255,0.35)"></span>
    <span style="font-family:var(--mono);font-size:9px;color:rgba(255,255,255,0.2);margin-left:12px">v2.0</span>
  </div>
</header>

<div class="layout">

<!-- ‚ïê‚ïê‚ïê SIDEBAR ‚ïê‚ïê‚ïê -->
<aside class="sidebar">

  <div id="sessionNotice" style="display:none;margin:10px 12px 0;padding:8px 12px;background:#e8f4ff;border:1px solid #2655d4;border-radius:6px;font-size:10px;color:#1a3a8a;font-family:var(--mono);line-height:1.5;"></div>

  <div class="sb-sec">
    <div class="sb-title">Upload Files</div>
    <div class="upload-card approved" id="cardA">
      <input type="file" accept=".xlsx,.xls,.csv" onchange="loadFile(this,'approved')">
      <div class="uc-icon">üìó</div>
      <div class="uc-type approved">Approved</div>
      <div class="uc-hint" id="hintA">Click to upload</div>
      <div class="uc-fname" id="fnameA"></div>
    </div>
    <div class="upload-card pending" id="cardP">
      <input type="file" accept=".xlsx,.xls,.csv" onchange="loadFile(this,'pending')">
      <div class="uc-icon">üìô</div>
      <div class="uc-type pending">Pending</div>
      <div class="uc-hint" id="hintP">Click to upload</div>
      <div class="uc-fname" id="fnameP"></div>
    </div>
  </div>

  <div class="sb-sec">
    <div class="sb-title">Summary</div>
    <div class="stats-grid">
      <div class="stat-box"><div class="stat-num t" id="sTotal">0</div><div class="stat-lbl">Total</div></div>
      <div class="stat-box"><div class="stat-num a" id="sAppr">0</div><div class="stat-lbl">Approved</div></div>
      <div class="stat-box"><div class="stat-num p" id="sPend">0</div><div class="stat-lbl">Pending</div></div>
      <div class="stat-box"><div class="stat-num c" id="sConf">0</div><div class="stat-lbl">Conflicts</div></div>
      <div class="stat-box"><div class="stat-num r" id="sRemv">0</div><div class="stat-lbl">Removed</div></div>
      <div class="stat-box"><div class="stat-num" style="color:var(--accent)" id="sRooms">0</div><div class="stat-lbl">Rooms</div></div>
    </div>
  </div>

  <div class="sb-sec">
    <div class="sb-title">Filter</div>
    <div class="filter-group">
      <button class="filter-btn fall active" onclick="setFilter('all')"><div class="fb-dot"></div>All Exams<span class="fb-count" id="fcAll">0</span></button>
      <button class="filter-btn fappr" onclick="setFilter('approved')"><div class="fb-dot"></div>Approved<span class="fb-count" id="fcAppr">0</span></button>
      <button class="filter-btn fpend" onclick="setFilter('pending')"><div class="fb-dot"></div>Pending<span class="fb-count" id="fcPend">0</span></button>
      <button class="filter-btn fconf" onclick="setFilter('conflict')"><div class="fb-dot"></div>Conflicts<span class="fb-count" id="fcConf">0</span></button>
      <button class="filter-btn fremv" onclick="setFilter('removed')"><div class="fb-dot"></div>Not in Latest<span class="fb-count" id="fcRemv">0</span></button>
      <div id="unassignedWarn" style="display:none;margin-top:8px;padding:6px 10px;background:#fff3cd;border:1px solid #f0ad00;border-radius:6px;font-size:10px;color:#7a5000;font-family:var(--mono);line-height:1.4;"></div>
      <div id="removedWarn" style="display:none;margin-top:6px;padding:6px 10px;background:#fff1e0;border:1px solid #b85c00;border-radius:6px;font-size:10px;color:#7a3d00;font-family:var(--mono);line-height:1.4;"></div>
    </div>
  </div>

  <div class="sb-sec">
    <div class="sb-title">Legend</div>
    <div class="legend-row"><div class="legend-sw" style="background:#e6f5ed;border-color:#1a7a4a44"></div>Approved</div>
    <div class="legend-row"><div class="legend-sw" style="background:#fef9e6;border-color:#8a650044"></div>Pending</div>
    <div class="legend-row"><div class="legend-sw" style="background:#fdecea;border-color:#c0281a44"></div>Conflict</div>
    <div class="legend-row"><div class="legend-sw" style="background:#fff1e0;border-color:#b85c0044"></div>Not in Latest Upload</div>
    <div style="margin-top:5px;font-size:10px;color:var(--muted);font-family:var(--mono)">Block height = exam duration</div>
  </div>

  <div class="sb-sec">
    <div class="sb-title">Office / Overflow Rooms</div>
    <div class="office-list" id="officeList"></div>
    <div class="add-office-row">
      <input id="offRoomIn" placeholder="302" style="width:54px;flex:none">
      <input id="offNameIn" placeholder="Name" style="flex:1">
      <select id="offFloorIn" style="font-family:var(--mono);font-size:11px;padding:5px 6px;border-radius:6px;border:1px solid var(--border);background:var(--bg);color:var(--text);outline:none;cursor:pointer">
        <option value="3rd">3rd Fl</option>
        <option value="4th" selected>4th Fl</option>
        <option value="computer">Computer Lab</option>
      </select>
      <button onclick="addOfficeRoom()">+</button>
    </div>
  </div>

  <div class="sb-sec" style="margin-top:auto">
    <button class="export-btn" id="exportBtn" onclick="exportExcel()" disabled>‚¨á Export Excel</button>
    <button onclick="clearHistory()" style="margin-top:8px;width:100%;padding:7px;background:transparent;border:1px solid var(--border2);border-radius:6px;color:var(--muted);font-size:10px;cursor:pointer;font-family:var(--mono)" onmouseover="this.style.borderColor='#c0281a';this.style.color='#c0281a'" onmouseout="this.style.borderColor='var(--border2)';this.style.color='var(--muted)'">üóë Clear Saved History</button>
  </div>

</aside>

<!-- ‚ïê‚ïê‚ïê MAIN ‚ïê‚ïê‚ïê -->
<main class="main">
  <div class="topbar">
    <span class="topbar-label">Date:</span>
    <div class="date-tabs" id="dateTabs" style="display:flex;gap:6px;flex-wrap:wrap"></div>
  </div>
  <div class="table-area">
    <div class="empty-state" id="emptyState">
      <div class="empty-icon">üìã</div>
      <div class="empty-title">No data loaded</div>
      <div class="empty-sub">Upload your Approved and/or Pending Accommodate exports using the sidebar to get started.</div>
    </div>
    <div class="grid-wrap" id="gridWrap" style="display:none">
      <div id="gridContainer"></div>
    </div>
  </div>
</main>

</div>
<div class="tooltip" id="tooltip"></div>

<script>
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// CONSTANTS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const SLOT_MIN = 30; // minutes per row

// Known room ‚Üí floor mapping
const ROOM_FLOOR_MAP = {
  'FINALS Smith Library 3rd':    '3rd',
  'FINALS Smith Library 4th':    '4th',
  'FINALS Computer Lab Spring 2026': 'computer',
};

// Pre-loaded office rooms
const DEFAULT_OFFICES = [
  {room:'302', name:'Joel',      floor:'3rd'},
  {room:'402', name:'Lori',      floor:'4th'},
  {room:'403', name:'Leigh',     floor:'4th'},
  {room:'404', name:'Romaine',   floor:'4th'},
  {room:'405', name:'Elizabeth', floor:'4th'},
  {room:'407', name:'Taylor',    floor:'4th'},
  {room:'408', name:'Sarah',     floor:'4th'},
  {room:'409', name:'Jennifer',  floor:'4th'},
  {room:'411', name:'Kaitlyn',   floor:'4th'},
  {room:'413', name:'Jenny',     floor:'4th'},
  {room:'415', name:'Dana',      floor:'4th'},
  {room:'417', name:'Anna',      floor:'4th'},
  {room:'424', name:'Mike',      floor:'4th'},
  {room:'426', name:'Paul',      floor:'4th'},
  {room:'428', name:'Leslie',    floor:'4th'},
  {room:'430', name:'Courtney',  floor:'4th'},
  {room:'432', name:'Arcelle',   floor:'4th'},
  {room:'434', name:'Jason',     floor:'4th'},
  {room:'436', name:'Kaitlynne', floor:'4th'},
  {room:'444', name:'Mary Beth', floor:'4th'},
  {room:'446', name:'Brandon',   floor:'4th'},
  {room:'448', name:'Christie',  floor:'4th'},
  {room:'450', name:'Steven',    floor:'4th'},
];

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// STATE
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
let allRecords    = [];      // from file uploads
let prevRecords   = [];      // snapshot before re-upload (for "removed" detection)
let officeRooms   = [...DEFAULT_OFFICES];
let currentFilter = 'all';
let currentDate   = null;
let uploadCount   = { approved: 0, pending: 0 };

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// INIT
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
document.addEventListener('DOMContentLoaded', () => {
  renderOfficeList();
  restoreSessionBaseline();
});

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// OFFICE ROOMS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function renderOfficeList() {
  const el = document.getElementById('officeList');
  el.innerHTML = officeRooms.map((o, i) => `
    <div class="office-item">
      <span class="oi-room">${o.room}</span>
      <span class="oi-name">${o.name}</span>
      <span class="oi-floor">${o.floor === 'computer' ? 'Lab' : o.floor + ' fl'}</span>
      <button class="office-rm-del" onclick="removeOffice(${i})" title="Remove">√ó</button>
    </div>`).join('');
}

function addOfficeRoom() {
  const room  = document.getElementById('offRoomIn').value.trim();
  const name  = document.getElementById('offNameIn').value.trim();
  const floor = document.getElementById('offFloorIn').value;
  if (!room) return;
  officeRooms.push({ room, name: name || room, floor });
  document.getElementById('offRoomIn').value = '';
  document.getElementById('offNameIn').value = '';
  renderOfficeList();
  renderGrid();
}

function removeOffice(i) {
  officeRooms.splice(i, 1);
  renderOfficeList();
  renderGrid();
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// FILE LOADING
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function loadFile(input, type) {
  const file = input.files[0];
  if (!file) return;

  document.getElementById(type === 'approved' ? 'hintA' : 'hintP').textContent = '‚úì Loaded';
  document.getElementById(type === 'approved' ? 'fnameA' : 'fnameP').textContent = file.name;
  document.getElementById(type === 'approved' ? 'cardA'  : 'cardP').classList.add('loaded');
  document.getElementById('lastUpload').textContent = 'Last upload: ' + new Date().toLocaleTimeString();

  const reader = new FileReader();
  reader.onload = e => {
    try {
      let rows;
      if (file.name.toLowerCase().endsWith('.csv')) {
        rows = parseCSV(e.target.result);
      } else {
        const wb = XLSX.read(e.target.result, { type: 'binary', cellDates: true });
        rows = XLSX.utils.sheet_to_json(wb.Sheets[wb.SheetNames[0]], { defval: '', raw: false });
      }
      processRows(rows, type);
    } catch(err) { alert('Error reading file: ' + err.message); }
  };
  file.name.toLowerCase().endsWith('.csv') ? reader.readAsText(file) : reader.readAsBinaryString(file);
}

function parseCSV(text) {
  const lines = text.split('\n').filter(l => l.trim());
  const headers = lines[0].split(',').map(h => h.trim().replace(/^"|"$/g,''));
  return lines.slice(1).map(line => {
    const vals = splitCSV(line);
    const obj = {};
    headers.forEach((h,i) => obj[h] = (vals[i]||'').trim().replace(/^"|"$/g,''));
    return obj;
  });
}

function splitCSV(line) {
  const r=[]; let c=''; let q=false;
  for (const ch of line) {
    if (ch==='"') q=!q;
    else if (ch===',' && !q) { r.push(c); c=''; }
    else c+=ch;
  }
  r.push(c); return r;
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// PROCESS ROWS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function processRows(rows, fileType) {
  if (!rows.length) return;

  // Reset floor caches so new building names get fresh labels/colors
  Object.keys(_floorLabelCache).forEach(k => delete _floorLabelCache[k]);
  Object.keys(_floorColorCache).forEach(k => delete _floorColorCache[k]);
  _floorColorIdx = 0;

  // Snapshot existing records of this type for "removed" detection
  const prevOfType = allRecords.filter(r => r.fileType === fileType).map(r => r.student + '|' + r.date);

  const parsed = rows.map(row => {
    const student  = row['Student']           || '';
    const room     = row['Testing Room']      || '';
    const slot     = row['Testing Room Slot'] || '';
    const dateRaw  = row['Testing Date']      || '';
    const startRaw = row['Testing Time']      || '';
    const endRaw   = row['End Time']          || '';
    const durRaw   = row['Test Length']       || '';
    const course   = cleanCourse(row['Course'] || '');
    const accom    = row['Accommodations']    || '';
    const exam     = row['Exams']             || '';

    if (!student) return null;

    const dateStr  = normDate(dateRaw);
    const startMin = parseTimeMins(startRaw);
    const endMin   = parseTimeMins(endRaw);
    const durMin   = (endMin !== null && startMin !== null) ? (endMin - startMin) : parseDurMins(durRaw);
    const slotNum  = parseInt((slot||'').replace(/\D/g,'')) || 999;
    const floor    = ROOM_FLOOR_MAP[room] || detectFloor(room);
    registerFloorLabel(floor, room);

    // If room matches a known office room number, treat as office assignment (no slot column)
    const matchedOffice = officeRooms.find(o =>
      o.room.trim().toLowerCase() === room.trim().toLowerCase() ||
      o.room.trim() === room.trim()
    );
    // Office assignment: matched an office room, OR has no slot and room looks like a room number (not a named testing room)
    const isOfficeAssignment = !!matchedOffice || (!slot && room && floor === 'other' && /^\d+/.test(room.trim()));

    return {
      student, room, slot: isOfficeAssignment ? '' : slot, slotNum, floor: matchedOffice ? matchedOffice.floor : floor,
      isOfficeAssignment, officeRoom: isOfficeAssignment ? room : null,
      date: dateStr, startMin, endMin, durMin, startRaw, endRaw,
      course, accom, exam,
      fileType,
      status: fileType,   // 'approved' | 'pending'
      removed: false,
      conflict: false, conflictWith: []
    };
  }).filter(Boolean);

  // Mark removed: was in previous upload of same type, not in new upload
  const newKeys = new Set(parsed.map(r => r.student + '|' + r.date));
  const removedRecords = allRecords
    .filter(r => r.fileType === fileType && !newKeys.has(r.student + '|' + r.date))
    .map(r => ({ ...r, removed: true, status: 'removed' }));

  // Replace records of this file type, keep other type + removed
  allRecords = [
    ...allRecords.filter(r => r.fileType !== fileType && r.status !== 'removed'),
    ...parsed,
    ...removedRecords,
  ];

  uploadCount[fileType]++;
  detectConflicts();
  saveToLocalStorage();
  refreshUI();
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// LOCAL STORAGE ‚Äî persist last session for day-over-day removed detection
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const LS_KEY = 'oars_scheduler_session';

function saveToLocalStorage() {
  try {
    const payload = {
      savedAt: new Date().toISOString(),
      records: allRecords.filter(r => !r.removed) // only save active records as baseline
    };
    localStorage.setItem(LS_KEY, JSON.stringify(payload));
  } catch(e) { console.warn('localStorage save failed:', e); }
}

function loadFromLocalStorage() {
  try {
    const raw = localStorage.getItem(LS_KEY);
    if (!raw) return null;
    return JSON.parse(raw);
  } catch(e) { return null; }
}

function clearHistory() {
  if (!confirm('Clear saved session history? This will reset the "Not in Latest Upload" baseline.')) return;
  try { localStorage.removeItem(LS_KEY); } catch(e) {}
  allRecords = [];
  uploadCount = { approved: 0, pending: 0 };
  const notice = document.getElementById('sessionNotice');
  if (notice) notice.style.display = 'none';
  refreshUI();
}

function restoreSessionBaseline() {
  const saved = loadFromLocalStorage();
  if (!saved || !saved.records || !saved.records.length) return;

  const savedDate = new Date(saved.savedAt);
  const today = new Date();
  const daysDiff = (today - savedDate) / (1000 * 60 * 60 * 24);

  // Restore as baseline ‚Äî mark all as "previous session" so removed detection works
  // Only restore if saved within last 14 days (safety valve)
  if (daysDiff > 14) return;

  allRecords = saved.records.map(r => ({ ...r, removed: false, conflict: false, conflictWith: [] }));

  // Show a subtle restore notice
  const notice = document.getElementById('sessionNotice');
  if (notice) {
    const d = savedDate.toLocaleDateString('en-US',{weekday:'short',month:'short',day:'numeric'});
    const t = savedDate.toLocaleTimeString('en-US',{hour:'numeric',minute:'2-digit'});
    notice.style.display = 'block';
    notice.innerHTML = `‚Ü© Previous session restored (${d} at ${t}) ‚Äî load today's files to see what changed`;
  }
}

function cleanCourse(c) {
  // Remove duplicate parenthetical codes like "(ENG-1103-02) (ENG-1103-02)"
  return c.replace(/(\s*\([^)]+\))\s*\1/g, '$1').replace(/\s*\([^)]+\)\s*\([^)]+\)$/, m => m.split(')')[0]+')').trim();
}

function detectFloor(room) {
  if (!room) return 'other';
  // Computer lab always first
  if (/computer/i.test(room)) return 'computer';
  // Extract any floor indicator: "1st", "2nd", "3rd", "4th", "5th" etc or "Floor 1" etc
  const m = room.match(/(\d+(?:st|nd|rd|th))\s*floor|\bfloor\s*(\d+)\b|(\d+(?:st|nd|rd|th))\b/i);
  if (m) return (m[1] || m[2] || m[3]).toLowerCase();
  return 'other';
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// CONFLICT DETECTION ‚Äî same slot + date + overlap
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function detectConflicts() {
  allRecords.forEach(r => { r.conflict = false; r.conflictWith = []; });
  const active = allRecords.filter(r => !r.removed);
  for (let i = 0; i < active.length; i++) {
    const a = active[i];
    if (a.startMin === null || a.endMin === null) continue;
    for (let j = i+1; j < active.length; j++) {
      const b = active[j];
      if (b.startMin === null || b.endMin === null) continue;
      if (a.date !== b.date) continue;
      // Same student taking two exams = not a conflict
      if ((a.student||'').trim().toLowerCase() === (b.student||'').trim().toLowerCase()) continue;
      // MUST match both slot number AND room (same physical seat in same building)
      if ((a.slot||'').toLowerCase() !== (b.slot||'').toLowerCase()) continue;
      if ((a.room||'').trim().toLowerCase() !== (b.room||'').trim().toLowerCase()) continue;
      if (a.startMin < b.endMin && b.startMin < a.endMin) {
        a.conflict = true; b.conflict = true;
        if (!a.conflictWith.includes(b.student)) a.conflictWith.push(b.student);
        if (!b.conflictWith.includes(a.student)) b.conflictWith.push(a.student);
      }
    }
  }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// UI REFRESH
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function refreshUI() {
  updateStats();
  buildDateTabs();
  if (!currentDate || !getDates().includes(currentDate)) currentDate = getDates()[0] || null;
  updateDateTabs();
  renderGrid();
  document.getElementById('exportBtn').disabled = allRecords.length === 0;
}

function getDates() {
  return [...new Set(allRecords.map(r => r.date))].filter(Boolean).sort((a,b) => new Date(a)-new Date(b));
}

function updateStats() {
  const appr     = allRecords.filter(r => r.status==='approved' && !r.removed).length;
  const pend     = allRecords.filter(r => r.status==='pending'  && !r.removed).length;
  const conf     = allRecords.filter(r => r.conflict).length;
  const remv     = allRecords.filter(r => r.removed).length;
  const unassign = allRecords.filter(r => !r.removed && !r.slot && !r.isOfficeAssignment).length;
  const rooms    = new Set(allRecords.filter(r=>!r.removed && r.slot).map(r=>r.room)).size;
  const total    = allRecords.filter(r=>!r.removed).length;
  document.getElementById('sTotal').textContent  = total;
  document.getElementById('sAppr').textContent   = appr;
  document.getElementById('sPend').textContent   = pend;
  document.getElementById('sConf').textContent   = conf;
  document.getElementById('sRemv').textContent   = remv;
  document.getElementById('sRooms').textContent  = rooms;
  document.getElementById('fcAll').textContent   = total;
  document.getElementById('fcAppr').textContent  = appr;
  document.getElementById('fcPend').textContent  = pend;
  document.getElementById('fcConf').textContent  = conf;
  document.getElementById('fcRemv').textContent  = remv;
  // Show unassigned warning with expandable student list
  const el = document.getElementById('unassignedWarn');
  if (el) {
    const unassignRecs = allRecords.filter(r => !r.removed && !r.slot && !r.isOfficeAssignment);
    if (unassignRecs.length === 0) { el.style.display = 'none'; }
    else {
      const byDate = {};
      unassignRecs.forEach(r => { if (!byDate[r.date]) byDate[r.date] = []; byDate[r.date].push(r); });
      const listHtml = Object.entries(byDate).sort(([a],[b])=>new Date(a)-new Date(b)).map(([date, recs]) => {
        const dateLabel = new Date(date).toLocaleDateString('en-US',{weekday:'short',month:'short',day:'numeric'});
        const rows = recs.map(r => `<div style="padding:2px 0 2px 8px;border-left:2px solid #f0ad00;margin:2px 0;font-size:10px">
          <span style="font-weight:600">${escH(r.student)}</span>
          <span style="color:#a07000;margin-left:4px">${r.startRaw}‚Äì${r.endRaw}</span>
        </div>`).join('');
        return `<div style="margin-top:5px"><div style="font-weight:700;font-size:10px;color:#7a5000">${dateLabel} (${recs.length})</div>${rows}</div>`;
      }).join('');
      el.style.display = 'block';
      el.innerHTML = `
        <div style="display:flex;justify-content:space-between;align-items:center;cursor:pointer" onclick="this.nextElementSibling.style.display=this.nextElementSibling.style.display==='none'?'block':'none'">
          <span>‚ö† ${unassignRecs.length} student${unassignRecs.length>1?'s':''} have no slot assigned</span>
          <span style="font-size:11px;opacity:0.7">‚ñº</span>
        </div>
        <div style="display:none;margin-top:6px;max-height:220px;overflow-y:auto">${listHtml}</div>
      `;
    }
  }
  // Show removed warning with expandable student list
  const elR = document.getElementById('removedWarn');
  if (elR) {
    const removedRecs = allRecords.filter(r => r.removed);
    if (removedRecs.length === 0) { elR.style.display = 'none'; }
    else {
      const byDate = {};
      removedRecs.forEach(r => { if (!byDate[r.date]) byDate[r.date] = []; byDate[r.date].push(r); });
      const listHtml = Object.entries(byDate).sort(([a],[b])=>new Date(a)-new Date(b)).map(([date, recs]) => {
        const dateLabel = new Date(date).toLocaleDateString('en-US',{weekday:'short',month:'short',day:'numeric'});
        const rows = recs.map(r => `<div style="padding:2px 0 2px 8px;border-left:2px solid #b85c00;margin:2px 0;font-size:10px">
          <span style="font-weight:600">${escH(r.student)}</span>
          <span style="color:#7a3d00;margin-left:4px">${r.startRaw}‚Äì${r.endRaw}</span>
        </div>`).join('');
        return `<div style="margin-top:5px"><div style="font-weight:700;font-size:10px;color:#7a3d00">${dateLabel} (${recs.length})</div>${rows}</div>`;
      }).join('');
      elR.style.display = 'block';
      elR.innerHTML = `
        <div style="display:flex;justify-content:space-between;align-items:center;cursor:pointer" onclick="this.nextElementSibling.style.display=this.nextElementSibling.style.display==='none'?'block':'none'">
          <span>‚ö† ${removedRecs.length} student${removedRecs.length>1?'s':''} not in latest upload</span>
          <span style="font-size:11px;opacity:0.7">‚ñº</span>
        </div>
        <div style="display:none;margin-top:6px;max-height:220px;overflow-y:auto">${listHtml}</div>
      `;
    }
  }
}

function buildDateTabs() {
  document.getElementById('dateTabs').innerHTML = getDates().map(d =>
    `<button class="date-tab${d===currentDate?' active':''}" onclick="selectDate('${d}')">${fmtDateLabel(d)}</button>`
  ).join('');
}

function updateDateTabs() {
  document.querySelectorAll('.date-tab').forEach(b => b.classList.toggle('active', b.textContent === fmtDateLabel(currentDate)));
}

function selectDate(d) { currentDate = d; updateDateTabs(); renderGrid(); }

function setFilter(f) {
  currentFilter = f;
  document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
  const map = { all:'fall', approved:'fappr', pending:'fpend', conflict:'fconf', removed:'fremv' };
  document.querySelector('.filter-btn.' + map[f]).classList.add('active');
  renderGrid();
}

// Global tooltip data store ‚Äî avoids all HTML escaping issues with inline JSON
const tipStore = {};
let tipIdx = 0;

function storeTip(data) {
  const id = 'tip_' + (tipIdx++);
  tipStore[id] = data;
  return id;
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// RENDER GRID
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function renderGrid() {
  const empty = document.getElementById('emptyState');
  const wrap  = document.getElementById('gridWrap');
  const cont  = document.getElementById('gridContainer');

  if (!allRecords.length && officeRooms.length === 0) {
    empty.style.display = 'flex'; wrap.style.display = 'none'; return;
  }
  if (!currentDate) { empty.style.display = 'flex'; wrap.style.display = 'none'; return; }

  empty.style.display = 'none'; wrap.style.display = 'block';

  // Filter
  let recs = allRecords.filter(r => r.date === currentDate);
  if      (currentFilter === 'approved') recs = recs.filter(r => r.status==='approved' && !r.conflict);
  else if (currentFilter === 'pending')  recs = recs.filter(r => r.status==='pending'  && !r.conflict);
  else if (currentFilter === 'conflict') recs = recs.filter(r => r.conflict);
  else if (currentFilter === 'removed')  recs = recs.filter(r => r.removed);

  // Time range from ALL records for this date (not filtered)
  const dateRecs = allRecords.filter(r => r.date === currentDate);
  const allTimes = [...dateRecs.map(r=>r.startMin), ...dateRecs.map(r=>r.endMin)].filter(x=>x!==null);

  let minT = allTimes.length ? Math.min(...allTimes) : 8*60;
  let maxT = allTimes.length ? Math.max(...allTimes) : 18*60;
  minT = Math.floor(minT / SLOT_MIN) * SLOT_MIN;
  maxT = Math.ceil(maxT  / SLOT_MIN) * SLOT_MIN;

  const timeSlots = [];
  for (let t = minT; t <= maxT; t += SLOT_MIN) timeSlots.push(t);

  // Build column order: floors from file data + office rooms
  const { floorGroups, allCols } = buildColumns(dateRecs);

  // ‚îÄ‚îÄ Build table using absolute-positioned blocks per column ‚îÄ‚îÄ
  // Each slot column becomes one tall <td> spanning all time rows.
  // Student blocks are positioned absolutely by (startMin - minT) within that td.
  // This eliminates all rowspan collision issues with staggered overlaps.

  const totalRows  = timeSlots.length;
  const totalH     = totalRows * 30;

  // Pre-group students by column index ‚Äî use filtered recs so filter buttons work
  // Office-assigned students (room = "407" etc) go into their matching office column
  const colStudents = allCols.map(col => {
    if (col.type === 'slot') {
      return recs.filter(r => !r.isOfficeAssignment && r.slot === col.slot && r.room === col.room);
    } else if (col.type === 'office') {
      return recs.filter(r => r.isOfficeAssignment &&
        r.room.trim().toLowerCase() === col.room.trim().toLowerCase());
    }
    return [];
  });

  // For each column, assign lanes so overlapping students sit side-by-side
  function layoutColumn(students) {
    if (!students.length) return [];
    const sorted = [...students].sort((a,b) => (a.startMin||0) - (b.startMin||0));
    const lanes = []; // each lane: endMin of last student in it
    const assigned = sorted.map(s => {
      const start = s.startMin || 0;
      const end   = s.endMin   || (start + (s.durMin || 60));
      // find first lane that ends at or before this student's start
      let lane = lanes.findIndex(endMin => endMin <= start);
      if (lane === -1) { lane = lanes.length; lanes.push(end); }
      else             { lanes[lane] = end; }
      return {...s, _lane: lane, _end: end};
    });
    const numLanes = lanes.length;
    return assigned.map(s => ({
      ...s,
      leftPct:  (s._lane / numLanes) * 100,
      widthPct: (1 / numLanes) * 100,
    }));
  }

  let html = '<table class="sched" style="table-layout:fixed">';

  // Floor header row
  html += '<thead><tr class="fhr"><th class="time-th floor-th" style="top:0;z-index:21"> </th>';
  floorGroups.forEach(([flKey, cols], gi) => {
    const divider = gi > 0 ? 'box-shadow:-3px 0 0 0 #4a6fff;' : '';
    html += `<th class="floor-th" colspan="${cols.length}" style="top:0;${divider}">${escH(floorDisplayLabel(flKey))}</th>`;
  });
  html += '</tr>';

  // Slot header row ‚Äî also add divider on first slot of each floor group
  const floorFirstCols = new Set(floorGroups.map(([,cols]) => cols[0]));
  html += '<tr class="shr"><th class="time-th" style="top:27px">Time</th>';
  for (const col of allCols) {
    const isFirst = floorFirstCols.has(col);
    const divider = isFirst ? 'box-shadow:-3px 0 0 0 #4a6fff;' : '';
    html += `<th style="top:27px;${divider}">${escH(col.label)}</th>`;
  }
  html += '</tr></thead><tbody>';

  // Single data row spanning all time slots ‚Äî time column uses individual cells,
  // slot columns use one tall td per column with absolute blocks inside
  // We still need individual time rows for the time column, so use a hybrid approach:
  // render normal rows but slot columns: first appearance = tall td with rowspan=totalRows + absolute blocks

  const colRendered = new Array(allCols.length).fill(false);

  // Pre-lay out all slot columns upfront so we can emit their tds on row 0
  const colLayouts = allCols.map((col, ci) => {
    if (col.type !== 'slot') return null;
    return layoutColumn(colStudents[ci]);
  });

  // Track which column indices are the first in their floor group (for divider lines)
  const floorDividerCols = new Set();
  let lastFloor = null;
  allCols.forEach((col, ci) => {
    if (col.floor !== lastFloor) { if (lastFloor !== null) floorDividerCols.add(ci); lastFloor = col.floor; }
  });

  timeSlots.forEach((t, ri) => {
    const isHour = t % 60 === 0;
    html += `<tr>`;
    html += `<td class="time-cell${isHour?' hour':''}">${minsToTime(t)}</td>`;

    allCols.forEach((col, ci) => {
      if (colRendered[ci]) return;
      const divStyle = floorDividerCols.has(ci) ? 'box-shadow:-3px 0 0 0 #4a6fff;' : '';

      if (col.type === 'slot') {
        colRendered[ci] = true;
        const spanRows = totalRows - ri;
        const tdH = totalRows * 30; // always full day height for correct absolute positioning

        let blocksHtml = '';
        colLayouts[ci].forEach(student => {
          const topPx    = (student.startMin - minT) * (30 / SLOT_MIN);
          const durM     = student.durMin || 60;
          const heightPx = Math.max(28, durM * (30 / SLOT_MIN) - 3);
          const leftPct  = student.leftPct;
          const widthPct = student.widthPct;
          const cls = student.removed ? 'removed' : student.conflict ? 'conflict' : student.status;
          const courseShort = (student.course||'').split('(')[0].trim().substring(0, 38);
          const badges = [];
          if (student.conflict) badges.push('<span class="sb-badge conflict">‚ö† CONFLICT</span>');
          if (student.removed)  badges.push('<span class="sb-badge removed">‚ö† NOT IN LATEST</span>');
          const tipId = storeTip({
            name: student.student, course: student.course, accom: student.accom,
            exam: student.exam, start: student.startRaw, end: student.endRaw,
            dur: student.durMin, slot: student.slot, room: student.room,
            status: student.status, removed: student.removed,
            conflict: student.conflict, conflictWith: student.conflictWith
          });
          blocksHtml += `<div class="sb ${cls}" style="
              position:absolute;
              top:${topPx}px; height:${heightPx}px;
              left:calc(${leftPct}% + 2px); width:calc(${widthPct}% - 4px);
              box-sizing:border-box;"
            onmouseenter="showTip(event,'${tipId}')" onmouseleave="hideTip()">
            <div class="sb-name">${escH(student.student)}</div>
            <div class="sb-course">${escH(courseShort)}</div>
            <div class="sb-accom">${escH(student.accom||'')}</div>
            ${badges.join('')}
          </div>`;
        });

        html += `<td rowspan="${spanRows}" style="height:${tdH}px;min-height:${tdH}px;overflow:visible;position:relative;padding:0;vertical-align:top;${divStyle}">
          ${blocksHtml}
        </td>`;

      } else if (col.type === 'office') {
        colRendered[ci] = true;
        const spanRows = totalRows - ri;
        const tdH = totalRows * 30;

        const laid = layoutColumn(colStudents[ci]);
        let blocksHtml = '';
        laid.forEach(student => {
          const topPx    = (student.startMin - minT) * (30 / SLOT_MIN);
          const durM     = student.durMin || 60;
          const heightPx = Math.max(28, durM * (30 / SLOT_MIN) - 3);
          const cls = student.removed ? 'removed' : student.conflict ? 'conflict' : student.status;
          const courseShort = (student.course||'').split('(')[0].trim().substring(0, 38);
          const badges = [];
          if (student.conflict) badges.push('<span class="sb-badge conflict">‚ö† CONFLICT</span>');
          if (student.removed)  badges.push('<span class="sb-badge removed">‚ö† NOT IN LATEST</span>');
          const tipId = storeTip({
            name: student.student, course: student.course, accom: student.accom,
            exam: student.exam, start: student.startRaw, end: student.endRaw,
            dur: student.durMin, slot: student.slot, room: student.room,
            status: student.status, removed: student.removed,
            conflict: student.conflict, conflictWith: student.conflictWith
          });
          blocksHtml += `<div class="sb ${cls}" style="
              position:absolute;
              top:${topPx}px; height:${heightPx}px;
              left:calc(${student.leftPct}% + 2px); width:calc(${student.widthPct}% - 4px);
              box-sizing:border-box;"
            onmouseenter="showTip(event,'${tipId}')" onmouseleave="hideTip()">
            <div class="sb-name">${escH(student.student)}</div>
            <div class="sb-course">${escH(courseShort)}</div>
            <div class="sb-accom">${escH(student.accom||'')}</div>
            ${badges.join('')}
          </div>`;
        });

        html += `<td rowspan="${spanRows}" class="office-cell" style="height:${tdH}px;min-height:${tdH}px;overflow:visible;position:relative;padding:0;vertical-align:top;${divStyle}">
          ${blocksHtml}
        </td>`;
      }
    });

    html += '</tr>';
  });

  html += '</tbody></table>';
  cont.innerHTML = html;
}

function SLOT_MIN_PX() { return 30; }

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// BUILD COLUMNS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function buildColumns(dateRecs) {
  // Key by room+slot so same slot number in 3rd vs 4th floor = separate columns
  const seen = new Set();
  const dataSlots = [];
  dateRecs.forEach(r => {
    if (r.isOfficeAssignment) return; // goes to office column, not slot column
    const key = (r.room||'') + '|||' + (r.slot||'');
    if (r.slot && !seen.has(key)) {
      seen.add(key);
      dataSlots.push({ type:'slot', slot: r.slot, room: r.room, floor: r.floor, slotNum: r.slotNum, label: slotLabel(r.slot) });
    }
  });
  dataSlots.sort((a,b) => floorOrder(a.floor) - floorOrder(b.floor) || a.slotNum - b.slotNum);

  // Office rooms as columns
  const officeCols = officeRooms.map(o => ({
    type: 'office', room: o.room, name: o.name, floor: o.floor,
    label: `${o.room} - ${o.name}`
  })).sort((a,b) => floorOrder(a.floor) - floorOrder(b.floor) || a.room.localeCompare(b.room, undefined, {numeric:true}));

  const allCols = [...dataSlots, ...officeCols];

  // Group into floors for header ‚Äî slot cols grouped by floor, offices always last as own group
  const floorMap = new Map();
  dataSlots.forEach(col => {
    const flKey = col.floor || 'other';
    if (!floorMap.has(flKey)) floorMap.set(flKey, []);
    floorMap.get(flKey).push(col);
  });
  if (officeCols.length) floorMap.set('offices', officeCols);

  // Sort floor groups by floorOrder (offices always last)
  const floorGroups = [...floorMap.entries()]
    .sort(([a],[b]) => {
      if (a === 'offices') return 1;
      if (b === 'offices') return -1;
      return floorOrder(a) - floorOrder(b);
    });
  return { floorGroups, allCols };
}

function floorOrder(f) {
  if (f === 'computer') return 0;
  // Extract number from floor key like "1st", "2nd", "3rd", "4th"
  const n = parseInt((f||'').replace(/\D/g,''));
  if (!isNaN(n)) return n;
  return 999;
}

// Cache display labels derived from actual room names in the data
const _floorLabelCache = {};
function registerFloorLabel(floor, room) {
  if (_floorLabelCache[floor] || !room) return;
  if (floor === 'computer') { _floorLabelCache[floor] = 'Computer Lab'; return; }
  if (floor === 'other')    { _floorLabelCache[floor] = 'Other'; return; }
  // Build label from room name: strip slot/number suffixes, keep building + floor
  // e.g. "FINALS Johnson Hall 3rd Floor" ‚Üí "Johnson Hall ‚Äî 3rd Floor"
  let label = room.replace(/^finals\s*/i,'').replace(/\s*slot[-\s]*\d+/i,'').trim();
  _floorLabelCache[floor] = label || floor;
}
function floorDisplayLabel(f) {
  if (f === 'offices') return 'Office Rooms';
  return _floorLabelCache[f] || f || 'Other';
}

function slotLabel(slot) {
  return 'Slot ' + (slot||'').replace(/\D/g,'');
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// TOOLTIP
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function showTip(e, tipId) {
  const d = tipStore[tipId];
  if (!d) return;
  const tip = document.getElementById('tooltip');
  const statusColor = d.removed ? '#b85c00' : d.conflict ? '#c0281a' : d.status==='approved' ? '#1a7a4a' : '#8a6500';
  tip.innerHTML = `
    <div style="font-weight:700;font-size:13px;margin-bottom:4px">${escH(d.name)}</div>
    <div style="color:#aaa;font-size:11px">${escH(d.room)} ¬∑ ${escH(d.slot)}</div>
    <div style="margin-top:5px">${escH(d.start)} ‚Äì ${escH(d.end)} <span style="color:#888">(${fmtDur(d.dur)})</span></div>
    <div style="margin-top:3px;color:#ddd">${escH(d.course)}</div>
    ${d.exam ? `<div style="color:#aaa;font-size:11px;margin-top:2px">Exam: ${escH(d.exam)}</div>` : ''}
    <div style="color:#bbb;font-style:italic;font-size:10px;margin-top:3px">${escH(d.accom)}</div>
    <div style="margin-top:5px">
      <span style="background:${statusColor};color:#fff;font-size:9px;padding:2px 7px;border-radius:3px;font-family:monospace">
        ${d.removed ? 'NOT IN LATEST UPLOAD' : (d.conflict ? 'CONFLICT' : d.status.toUpperCase())}
      </span>
    </div>
    ${d.conflict ? `<div style="color:#f88;margin-top:4px;font-size:11px">‚ö† Conflicts with: ${d.conflictWith.map(escH).join(', ')}</div>` : ''}
    ${d.removed  ? `<div style="color:#f5a342;margin-top:4px;font-size:11px">‚ö† This student was in a previous upload but not the latest one. Verify status.</div>` : ''}
  `;
  tip.style.display = 'block';
  posTip(e);
}

function hideTip() { document.getElementById('tooltip').style.display = 'none'; }

function posTip(e) {
  const tip = document.getElementById('tooltip');
  let x = e.clientX+14, y = e.clientY+14;
  if (x+290 > window.innerWidth)  x = e.clientX-294;
  if (y+240 > window.innerHeight) y = e.clientY-220;
  tip.style.left = x+'px'; tip.style.top = y+'px';
}

document.addEventListener('mousemove', e => {
  if (document.getElementById('tooltip').style.display==='block') posTip(e);
});

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// EXPORT EXCEL ‚Äî raw XML/ZIP, pixel-perfect colors
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// Color palette ‚Äî exact match to CSS
const XL = {
  hdrTime:   '10141E', hdrSlot:   '1A1F2E',
  timeHrBg:  'E8EDF7', timeHrTx:  '1A1F2E',
  timeBg:    'F8F9FC', timeTx:    '6B7494',
  apprBg:    'E6F5ED', apprTx:    '1A7A4A', apprBrd: '1A7A4A',
  pendBg:    'FEF9E6', pendTx:    '8A6500', pendBrd: '8A6500',
  confBg:    'FDECEA', confTx:    'C0281A', confBrd: 'C0281A',
  remvBg:    'FFF1E0', remvTx:    'B85C00', remvBrd: 'B85C00',
  offcBg:    'F5F7FF', offcHasBg: 'EEF2FF', offcTx:  '1E3A8A', offcBrd: 'C7D2FE',
  emptyHr:   'F4F6FB', empty:     'FAFBFF',
  brdLt:     'EAEDF3', brdMd:     'D8DCE6',
  white:     'FFFFFF',
};

// Dynamic floor color palette ‚Äî cycles through these for any floor encountered
const FLOOR_PALETTE = [
  { bg: '1A3A2A', tx: '7EFFD4' }, // computer lab ‚Äî teal
  { bg: '1B2A6B', tx: '7EA5FF' }, // 1st floor ‚Äî blue
  { bg: '1B3A5C', tx: '7EC8FF' }, // 2nd floor ‚Äî light blue
  { bg: '3A1B5C', tx: 'C8AAFF' }, // 3rd floor ‚Äî purple
  { bg: '5C1B3A', tx: 'FFAACC' }, // 4th floor ‚Äî rose
  { bg: '3A3A1B', tx: 'FFFFA0' }, // 5th floor ‚Äî yellow
  { bg: '1B3A3A', tx: 'A0FFEE' }, // 6th floor ‚Äî cyan
];
const _floorColorCache = {};
let _floorColorIdx = 0;
function xlFloorColors(f) {
  if (f === 'computer') return FLOOR_PALETTE[0];
  if (!_floorColorCache[f]) {
    // Assign next palette color (skip index 0 = computer)
    _floorColorIdx++;
    _floorColorCache[f] = FLOOR_PALETTE[_floorColorIdx % FLOOR_PALETTE.length];
  }
  return _floorColorCache[f];
}
function xlFloorBg(f) { return xlFloorColors(f).bg; }
function xlFloorTx(f) { return xlFloorColors(f).tx; }

function getStatusColors(r) {
  if (r.removed)  return [XL.remvBg, XL.remvTx, XL.remvBrd];
  if (r.conflict) return [XL.confBg, XL.confTx, XL.confBrd];
  if (r.status === 'pending') return [XL.pendBg, XL.pendTx, XL.pendBrd];
  return [XL.apprBg, XL.apprTx, XL.apprBrd];
}

// Style registry ‚Äî build a shared styles.xml
class StyleRegistry {
  constructor() {
    this.fills   = ['none','gray125']; // index 0,1 reserved
    this.fonts   = [];
    this.borders = [];
    this.xfs     = [];
    this._fillIdx = {}; this._fontIdx = {}; this._borderIdx = {}; this._xfIdx = {};
  }
  addFill(rgb) {
    const k = rgb;
    if (this._fillIdx[k] === undefined) { this._fillIdx[k] = this.fills.length; this.fills.push(rgb); }
    return this._fillIdx[k];
  }
  addFont(cfg) {
    const k = JSON.stringify(cfg);
    if (this._fontIdx[k] === undefined) { this._fontIdx[k] = this.fonts.length; this.fonts.push(cfg); }
    return this._fontIdx[k];
  }
  addBorder(cfg) {
    const k = JSON.stringify(cfg);
    if (this._borderIdx[k] === undefined) { this._borderIdx[k] = this.borders.length; this.borders.push(cfg); }
    return this._borderIdx[k];
  }
  xf(fillId, fontId, borderId, wrap=false, hAlign='left', vAlign='top') {
    const k = `${fillId}|${fontId}|${borderId}|${wrap}|${hAlign}|${vAlign}`;
    if (this._xfIdx[k] === undefined) { this._xfIdx[k] = this.xfs.length; this.xfs.push({fillId,fontId,borderId,wrap,hAlign,vAlign}); }
    return this._xfIdx[k];
  }
  xml() {
    const fillsXml = this.fills.map((f,i) => {
      if (i < 2) return i===0
        ? '<fill><patternFill patternType="none"/></fill>'
        : '<fill><patternFill patternType="gray125"/></fill>';
      return `<fill><patternFill patternType="solid"><fgColor rgb="FF${f}"/></patternFill></fill>`;
    }).join('');
    const fontsXml = this.fonts.map(f => {
      let s = '<font>';
      if (f.bold)   s += '<b/>';
      if (f.italic) s += '<i/>';
      s += `<sz val="${f.sz||9}"/>`;
      s += `<color rgb="FF${f.rgb||'000000'}"/>`;
      s += `<name val="${f.name||'Arial'}"/>`;
      s += '</font>';
      return s;
    }).join('');
    const bordersXml = this.borders.map(b => {
      const side = (s) => s ? `<${s.side} style="${s.style}"><color rgb="FF${s.color}"/></${s.side}>` : '';
      return `<border>${side(b.left)}${side(b.right)}${side(b.top)}${side(b.bottom)}</border>`;
    }).join('');
    const xfsXml = this.xfs.map(x =>
      `<xf numFmtId="0" fontId="${x.fontId}" fillId="${x.fillId}" borderId="${x.borderId}" applyFont="1" applyFill="1" applyBorder="1" applyAlignment="1"><alignment horizontal="${x.hAlign}" vertical="${x.vAlign}" wrapText="${x.wrap?1:0}"/></xf>`
    ).join('');
    return `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<styleSheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main">
<fonts count="${this.fonts.length}">${fontsXml}</fonts>
<fills count="${this.fills.length}">${fillsXml}</fills>
<borders count="${this.borders.length}">${bordersXml}</borders>
<cellStyleXfs count="1"><xf numFmtId="0" fontId="0" fillId="0" borderId="0"/></cellStyleXfs>
<cellXfs count="${this.xfs.length}">${xfsXml}</cellXfs>
</styleSheet>`;
  }
}

// Build a border object
function mkBrd(left, right, top, bottom) {
  const s = (side, style, color) => side ? {side, style: style||'thin', color: color||XL.brdMd} : null;
  return { left: s('left',...(left||[])), right: s('right',...(right||[])), top: s('top',...(top||[])), bottom: s('bottom',...(bottom||[])) };
}

// Escape XML
function xe(s) { return String(s||'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#39;'); }

// Column letter helper
function colLetter(n) { // 0-indexed
  let s = ''; n++;
  while (n > 0) { s = String.fromCharCode(64 + (n%26||26)) + s; n = Math.floor((n-1)/26); }
  return s;
}

async function exportExcel() {
  if (!allRecords.length) return;

  const zip = new JSZip();
  const dates = getDates();
  const sheetNames = [];
  const sheetXmls = [];

  const sr = new StyleRegistry();

  // Pre-register fonts
  const fTimeHr = sr.addFont({rgb: XL.timeHrTx, bold:true, sz:9});
  const fTime   = sr.addFont({rgb: XL.timeTx,   bold:false,sz:9});
  const fHdrW   = sr.addFont({rgb: XL.white,     bold:true, sz:9});
  const fHdrFl  = (f) => sr.addFont({rgb: xlFloorTx(f), bold:true, sz:10});
  const fStudent= (rgb) => sr.addFont({rgb, bold:true, sz:9});
  const fDetail = (rgb) => sr.addFont({rgb, bold:false,sz:8});
  const fOffice = sr.addFont({rgb: XL.offcTx, sz:9});

  // Pre-register borders
  const bNone   = sr.addBorder({});
  const bTime   = sr.addBorder(mkBrd(['right','medium',XL.brdMd],['right','medium',XL.brdMd],null,['bottom','thin',XL.brdLt]));
  const bCell   = (brdColor) => sr.addBorder(mkBrd(['left','thick',brdColor],['right','thin',XL.brdMd],['top','thin',XL.brdMd],['bottom','thin',XL.brdMd]));
  const bEmpty  = sr.addBorder(mkBrd(null,['right','thin',XL.brdLt],null,['bottom','thin',XL.brdLt]));
  const bOffice = sr.addBorder(mkBrd(['left','thin',XL.offcBrd],['right','thin',XL.offcBrd],['top','thin',XL.offcBrd],['bottom','thin',XL.offcBrd]));
  const bHdr    = sr.addBorder(mkBrd(null,['right','thin','555555'],null,['bottom','thin','555555']));

  // Pre-register fills
  const flTimeHr = sr.addFill(XL.timeHrBg);
  const flTime   = sr.addFill(XL.timeBg);
  const flHdr    = sr.addFill(XL.hdrTime);
  const flHdrSl  = sr.addFill(XL.hdrSlot);
  const flFl     = (f) => sr.addFill(xlFloorBg(f));
  const flEmpty  = sr.addFill(XL.empty);
  const flEmptyHr= sr.addFill(XL.emptyHr);
  const flOffc   = sr.addFill(XL.offcBg);
  const flOffcHas= sr.addFill(XL.offcHasBg);
  const flStatus = ([bg]) => sr.addFill(bg);

  // XF shortcuts
  const xfTimeHr = () => sr.xf(flTimeHr, fTimeHr, bTime, false, 'right', 'top');
  const xfTime   = () => sr.xf(flTime,   fTime,   bTime, false, 'right', 'top');
  const xfHdrTm  = () => sr.xf(flHdr,    fHdrW,   bHdr,  false, 'center','center');
  const xfHdrSl  = () => sr.xf(flHdrSl,  fHdrW,   bHdr,  false, 'center','center');
  const xfFloor  = (f) => sr.xf(flFl(f), fHdrFl(f), bHdr, false,'center','center');
  const xfStudent= (colors) => sr.xf(flStatus(colors), fStudent(colors[1]), bCell(colors[2]), true, 'left','top');
  const xfEmpty  = (isHr) => sr.xf(isHr?flEmptyHr:flEmpty, fTime, bEmpty, false,'left','top');
  const xfOffice = (has) => sr.xf(has?flOffcHas:flOffc, fOffice, bOffice, true,'left','top');

  dates.forEach((date, di) => {
    const dateRecs = allRecords.filter(r => r.date === date);
    const {floorGroups, allCols} = buildColumns(dateRecs);

    const allTimes = [...dateRecs.map(r=>r.startMin),...dateRecs.map(r=>r.endMin)].filter(x=>x!=null);
    let minT = allTimes.length ? Math.floor(Math.min(...allTimes)/SLOT_MIN)*SLOT_MIN : 480;
    let maxT = allTimes.length ? Math.ceil(Math.max(...allTimes)/SLOT_MIN)*SLOT_MIN  : 1200;
    const timeSlots = [];
    for (let t=minT; t<=maxT; t+=SLOT_MIN) timeSlots.push(t);

    // Sheet safe name
    const d = new Date(date);
    const dn = isNaN(d) ? date : d.toLocaleDateString('en-US',{weekday:'short',month:'short',day:'numeric'});
    const sName = dn.replace(/[/\\?*\[\]:]/g,'-').substring(0,31);
    sheetNames.push(sName);

    // Merges list
    const merges = [];
    // Col defs
    const colDefs = [`<col min="1" max="1" width="11" customWidth="1"/>`];
    allCols.forEach((c,i) => colDefs.push(`<col min="${i+2}" max="${i+2}" width="${c.type==='office'?22:26}" customWidth="1"/>`));

    // Build rows array: each entry is array of cell objects {addr, v, s, t}
    const rows = [];

    // Row 1: floor group headers
    const r1 = [];
    r1.push({c:1, v:'', s: sr.xf(flHdr, fHdrW, bHdr, false,'center','center')});
    let ci2=2;
    for (const [fl, fcols] of floorGroups) {
      r1.push({c:ci2, v:floorDisplayLabel(fl), s: xfFloor(fl)});
      if (fcols.length>1) merges.push({s:{r:1,c:ci2},e:{r:1,c:ci2+fcols.length-1}});
      for (let i=1;i<fcols.length;i++) r1.push({c:ci2+i, v:'', s: xfFloor(fl)});
      ci2 += fcols.length;
    }
    rows.push({h:22, cells:r1});

    // Row 2: slot headers
    const r2 = [];
    r2.push({c:1, v:'Time', s: xfHdrTm()});
    allCols.forEach((col,i) => {
      r2.push({c:i+2, v:col.label, s: col.type==='office'
        ? sr.xf(sr.addFill('1A2850'), sr.addFont({rgb:'C7D2FE',bold:true,sz:9}), bHdr, false,'center','center')
        : xfHdrSl()
      });
    });
    rows.push({h:22, cells:r2});

    // Data rows
    const rsTrack = {}; allCols.forEach((_,i) => rsTrack[i]=0);

    timeSlots.forEach((t, ri) => {
      const isHour = t%60===0;
      const er = ri + 3; // excel row (1-based, rows 1&2 are headers)
      const rowCells = [];

      // Time cell
      rowCells.push({c:1, v:minsToTime(t), s: isHour ? xfTimeHr() : xfTime()});

      allCols.forEach((col, ci) => {
        const ec = ci+2;
        if (rsTrack[ci]>0) { rsTrack[ci]--; return; }

        if (col.type === 'slot') {
          // Find students whose exam overlaps this time slot (not just same start)
          const overlapping = allRecords.filter(r =>
            r.date===date && r.slot===col.slot && r.room===col.room &&
            r.startMin !== null && r.endMin !== null &&
            r.startMin <= t && r.endMin > t
          );
          // Only render on the row matching the earliest student's start, skip otherwise via rsTrack
          if (rsTrack[ci] > 0) { rsTrack[ci]--; }
          else if (overlapping.length > 0) {
            // Find max span needed from this row
            const maxSpan = Math.max(...overlapping.map(s=>Math.max(1,Math.ceil((s.endMin-t)/SLOT_MIN))));
            rsTrack[ci] = maxSpan - 1;
            if (maxSpan>1) merges.push({s:{r:er,c:ec},e:{r:er+maxSpan-1,c:ec}});

            const parts = overlapping.map(s => {
              const courseShort = (s.course||'').split('(')[0].trim();
              const lines = [
                `‚ñ∂ ${s.student}`,
                `  ${s.startRaw} ‚Äì ${s.endRaw} (${fmtDur(s.durMin)})`,
                `  ${courseShort}`,
              ];
              if (s.accom) lines.push(`  ${s.accom}`);
              if (s.conflict && s.conflictWith.length) lines.push(`  ‚ö† Conflict: ${s.conflictWith.join(', ')}`);
              if (s.removed) lines.push('  ‚ö† Not in latest upload');
              return lines.join('\n');
            });

            const refStudent  = overlapping.find(s=>s.conflict) || overlapping[0];
            const colors = getStatusColors(refStudent);
            const cellText = parts.join('\n' + '‚îÄ'.repeat(24) + '\n');
            rowCells.push({c:ec, v:cellText, s: xfStudent(colors)});
          } else {
            rowCells.push({c:ec, v:'', s: xfEmpty(isHour)});
          }

        } else {
          // Office column ‚Äî show any office-assigned students overlapping this time
          const overlapping = allRecords.filter(r =>
            r.date===date && r.isOfficeAssignment &&
            r.room.trim().toLowerCase() === col.room.trim().toLowerCase() &&
            r.startMin !== null && r.endMin !== null &&
            r.startMin <= t && r.endMin > t
          );
          if (rsTrack[ci] > 0) { rsTrack[ci]--; }
          else if (overlapping.length > 0) {
            const maxSpan = Math.max(...overlapping.map(s=>Math.max(1,Math.ceil((s.endMin-t)/SLOT_MIN))));
            rsTrack[ci] = maxSpan - 1;
            if (maxSpan>1) merges.push({s:{r:er,c:ec},e:{r:er+maxSpan-1,c:ec}});
            const parts = overlapping.map(s => {
              const courseShort = (s.course||'').split('(')[0].trim();
              const lines = [`‚ñ∂ ${s.student}`, `  ${s.startRaw} ‚Äì ${s.endRaw} (${fmtDur(s.durMin)})`, `  ${courseShort}`];
              if (s.accom) lines.push(`  ${s.accom}`);
              return lines.join('\n');
            });
            const colors = getStatusColors(overlapping.find(s=>s.conflict) || overlapping[0]);
            rowCells.push({c:ec, v:parts.join('\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n'), s: xfStudent(colors)});
          } else {
            rowCells.push({c:ec, v:'', s: xfOffice(false)});
          }
        }
      });

      rows.push({h:52, cells:rowCells});
    });

    // Build sheet XML
    let sheetXml = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<worksheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main"
 xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships">
<sheetViews><sheetView workbookViewId="0"><pane xSplit="1" ySplit="2" topLeftCell="B3" activePane="bottomRight" state="frozen"/></sheetView></sheetViews>
<sheetFormatPr defaultRowHeight="20"/>
<cols>${colDefs.join('')}</cols>
<sheetData>`;

    rows.forEach((row, ri) => {
      const rIdx = ri+1;
      sheetXml += `<row r="${rIdx}" ht="${row.h}" customHeight="1">`;
      row.cells.forEach(cell => {
        const addr = `${colLetter(cell.c-1)}${rIdx}`;
        const isStr = typeof cell.v === 'string';
        const v = isStr ? `<v>${xe(cell.v)}</v>` : `<v>${cell.v||0}</v>`;
        const t = isStr ? ' t="inlineStr"' : '';
        const inl = isStr ? `<is><t>${xe(cell.v)}</t></is>` : v;
        sheetXml += `<c r="${addr}" s="${cell.s}"${isStr?' t="inlineStr"':''}>${isStr?`<is><t xml:space="preserve">${xe(cell.v)}</t></is>`:`<v>${cell.v||0}</v>`}</c>`;
      });
      sheetXml += `</row>`;
    });

    sheetXml += `</sheetData>`;

    // Merges
    if (merges.length) {
      sheetXml += `<mergeCells count="${merges.length}">`;
      merges.forEach(m => {
        sheetXml += `<mergeCell ref="${colLetter(m.s.c-1)}${m.s.r}:${colLetter(m.e.c-1)}${m.e.r}"/>`;
      });
      sheetXml += `</mergeCells>`;
    }
    sheetXml += `</worksheet>`;
    sheetXmls.push(sheetXml);
  });

  // Summary sheet
  const confRecs   = allRecords.filter(r=>r.conflict);
  const removedRecs= allRecords.filter(r=>r.removed);
  const fBold = sr.addFont({rgb:'1A1F2E',bold:true,sz:10});
  const flSumHdr = sr.addFill('1A1F2E');
  const xfSumHdr = sr.xf(flSumHdr, sr.addFont({rgb:'FFFFFF',bold:true,sz:10}), bNone, false,'left','center');
  const xfSumLbl = sr.xf(sr.addFill('F0F2F5'), fBold, bNone, false,'left','center');
  const xfSumVal = sr.xf(0, sr.addFont({rgb:'1A1F2E',sz:10}), bNone, false,'left','center');

  let summXml = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<worksheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main">
<cols><col min="1" max="1" width="26" customWidth="1"/><col min="2" max="2" width="26" customWidth="1"/><col min="3" max="3" width="28" customWidth="1"/><col min="4" max="4" width="10" customWidth="1"/><col min="5" max="5" width="20" customWidth="1"/><col min="6" max="6" width="36" customWidth="1"/></cols>
<sheetData>`;
  let sr2 = 1;
  const srow = (cells) => {
    summXml += `<row r="${sr2}">`;
    cells.forEach(([col,val,style]) => {
      const addr=`${colLetter(col-1)}${sr2}`;
      const s = style||xfSumVal;
      summXml += `<c r="${addr}" s="${s}" t="inlineStr"><is><t>${xe(val)}</t></is></c>`;
    });
    summXml += `</row>`; sr2++;
  };
  srow([[1,'EXAM SCHEDULE SUMMARY',xfSumHdr],[2,'',xfSumHdr],[3,'',xfSumHdr],[4,'',xfSumHdr],[5,'',xfSumHdr]]);
  srow([[1,`Generated: ${new Date().toLocaleString()}`, xfSumVal]]);
  sr2++;
  srow([[1,'Metric',xfSumLbl],[2,'Count',xfSumLbl]]);
  [['Total Exams',          allRecords.filter(r=>!r.removed).length],
   ['Approved',             allRecords.filter(r=>r.status==='approved'&&!r.removed).length],
   ['Pending',              allRecords.filter(r=>r.status==='pending'&&!r.removed).length],
   ['Room Conflicts',       allRecords.filter(r=>r.conflict).length],
   ['Unassigned (no slot)', allRecords.filter(r=>!r.removed&&!r.slot&&!r.isOfficeAssignment).length],
   ['Not in Latest Upload', allRecords.filter(r=>r.removed).length]
  ].forEach(([k,v]) => srow([[1,k,xfSumVal],[2,String(v),xfSumVal]]));
  sr2++;
  if (confRecs.length) {
    srow([[1,'CONFLICTS',xfSumHdr],[2,'',xfSumHdr],[3,'',xfSumHdr],[4,'',xfSumHdr],[5,'',xfSumHdr],[6,'',xfSumHdr]]);
    srow([[1,'Date',xfSumLbl],[2,'Student',xfSumLbl],[3,'Room',xfSumLbl],[4,'Slot',xfSumLbl],[5,'Time',xfSumLbl],[6,'Conflicts With',xfSumLbl]]);
    confRecs.forEach(r => srow([[1,r.date],[2,r.student],[3,r.room],[4,r.slot],[5,`${r.startRaw}‚Äì${r.endRaw}`],[6,(r.conflictWith||[]).join(', ')]]));
    sr2++;
  }
  if (removedRecs.length) {
    srow([[1,'NOT IN LATEST UPLOAD',xfSumHdr],[2,'',xfSumHdr],[3,'',xfSumHdr],[4,'',xfSumHdr],[5,'',xfSumHdr]]);
    srow([[1,'Date',xfSumLbl],[2,'Student',xfSumLbl],[3,'Room',xfSumLbl],[4,'Slot',xfSumLbl],[5,'Last Seen',xfSumLbl]]);
    removedRecs.forEach(r => srow([[1,r.date],[2,r.student],[3,r.room],[4,r.slot],[5,`${r.startRaw}‚Äì${r.endRaw}`]]));
    sr2++;
  }
  const unassignRecs = allRecords.filter(r=>!r.removed&&!r.slot&&!r.isOfficeAssignment);
  if (unassignRecs.length) {
    srow([[1,'UNASSIGNED ‚Äî NO SLOT',xfSumHdr],[2,'',xfSumHdr],[3,'',xfSumHdr],[4,'',xfSumHdr],[5,'',xfSumHdr]]);
    srow([[1,'Date',xfSumLbl],[2,'Student',xfSumLbl],[3,'Room',xfSumLbl],[4,'Status',xfSumLbl],[5,'Time',xfSumLbl]]);
    unassignRecs
      .sort((a,b)=>new Date(a.date)-new Date(b.date)||a.student.localeCompare(b.student))
      .forEach(r => srow([[1,r.date],[2,r.student],[3,r.room],[4,r.status],[5,`${r.startRaw}‚Äì${r.endRaw}`]]));
  }
  summXml += `</sheetData>
</worksheet>`;

  sheetNames.push('Summary'); sheetXmls.push(summXml);

  // Assemble ZIP
  const n = sheetNames.length;
  const sheetsRels = sheetNames.map((_,i) =>
    `<Relationship Id="rId${i+1}" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet" Target="worksheets/sheet${i+1}.xml"/>`
  ).join('');
  const sheetElems = sheetNames.map((nm,i) =>
    `<sheet name="${xe(nm)}" sheetId="${i+1}" r:id="rId${i+1}"/>`
  ).join('');
  const contentTypes = sheetNames.map((_,i) =>
    `<Override PartName="/xl/worksheets/sheet${i+1}.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml"/>`
  ).join('');

  zip.file('[Content_Types].xml', `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
<Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>
<Default Extension="xml"  ContentType="application/xml"/>
<Override PartName="/xl/workbook.xml"   ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml"/>
<Override PartName="/xl/styles.xml"     ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml"/>
${contentTypes}
</Types>`);

  zip.file('_rels/.rels', `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
<Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="xl/workbook.xml"/>
</Relationships>`);

  zip.file('xl/workbook.xml', `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<workbook xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main"
 xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships">
<sheets>${sheetElems}</sheets>
</workbook>`);

  zip.file('xl/_rels/workbook.xml.rels', `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
${sheetsRels}
<Relationship Id="rId${n+1}" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles" Target="styles.xml"/>
</Relationships>`);

  zip.file('xl/styles.xml', sr.xml());
  sheetXmls.forEach((xml, i) => zip.file(`xl/worksheets/sheet${i+1}.xml`, xml));

  const blob = await zip.generateAsync({type:'blob', mimeType:'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = `ExamSchedule_${(getDates()[0]||'').replace(/\//g,'-')}.xlsx`;
  a.click();
  showNotif(`‚úÖ Exported ${dates.length} sheet${dates.length>1?'s':''} + Summary`);
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// HELPERS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function normDate(d) {
  if (!d) return '';
  if (typeof d==='object' && d instanceof Date) return d.toLocaleDateString('en-US',{month:'2-digit',day:'2-digit',year:'numeric'});
  const parsed = new Date(String(d).trim());
  if (!isNaN(parsed)) return parsed.toLocaleDateString('en-US',{month:'2-digit',day:'2-digit',year:'numeric'});
  return String(d);
}

function parseTimeMins(t) {
  if (!t || t==='-') return null;
  const s = String(t).trim().toUpperCase().replace(/\s+/,' ');
  const m = s.match(/^(\d{1,2}):(\d{2})\s*(AM|PM)?$/);
  if (!m) return null;
  let h=parseInt(m[1]), min=parseInt(m[2]);
  if (m[3]==='PM'&&h!==12) h+=12;
  if (m[3]==='AM'&&h===12) h=0;
  return h*60+min;
}

function parseDurMins(d) {
  if (!d) return 60;
  const s=String(d).trim(); let m;
  if ((m=s.match(/^(\d+)$/))) { const n=parseInt(m[1]); return n>12?n:n*60; }
  if ((m=s.match(/(\d+(?:\.\d+)?)\s*h/i))) return Math.round(parseFloat(m[1])*60);
  if ((m=s.match(/(\d+)\s*m/i))) return parseInt(m[1]);
  return 60;
}

function minsToTime(m) {
  if (m==null) return '‚Äî';
  const h=Math.floor(m/60)%24, mn=m%60, ap=h>=12?'pm':'am', hh=h%12||12;
  return `${hh}:${String(mn).padStart(2,'0')} ${ap}`;
}

function fmtDur(m) {
  if (!m) return '‚Äî';
  const h=Math.floor(m/60), mn=m%60;
  if (!h) return `${mn}m`; if (!mn) return `${h}h`; return `${h}h ${mn}m`;
}

function fmtDateLabel(d) {
  if (!d) return '';
  const p=d.split('/');
  if (p.length===3) {
    const dt=new Date(parseInt(p[2]),parseInt(p[0])-1,parseInt(p[1]));
    if (!isNaN(dt)) return dt.toLocaleDateString('en-US',{weekday:'short',month:'short',day:'numeric'});
  }
  return d;
}

function escH(s) {
  return String(s||'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');
}

function showNotif(msg) {
  const n=document.createElement('div'); n.className='notif'; n.textContent=msg;
  document.body.appendChild(n); setTimeout(()=>n.remove(),4000);
}
</script>
</body>
</html>
